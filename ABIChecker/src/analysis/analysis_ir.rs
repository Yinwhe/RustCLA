use std::fs::File;
use std::io::{prelude::*, BufReader};
use std::path::{Path, PathBuf};

use inkwell::context::Context;
use inkwell::module::Module;

use super::ir_info::IRInfo;

pub fn analysis_ir(path: PathBuf, targets: Vec<String>) -> Result<(), String>{
    let cx = Context::create();
    let mut ir_info = resolve_from_bc(path, targets, &cx)?;

    // ir_info.test();
    ir_info.get_ffi()?;

    unimplemented!()
}


/// Resolve the IR from the bitcode file and collect all modules.
fn resolve_from_bc<'a>(path: PathBuf, targets: Vec<String>, cx: &'a Context) -> Result<IRInfo<'a>, String> {
    let file = File::open(path).map_err(|e| format!("{}", e))?;
    let lines = BufReader::new(file).lines();

    // let cx = Context::create();
    let mut c_modules = Vec::new();
    let mut r_modules = Vec::new();

    // read each bitcode file and collect the IR
    for line in lines {
        let line = line.map_err(|e| format!("{}", e))?;
        let path = Path::new(&line);
        let module = Module::parse_bitcode_from_path(path, cx).map_err(|e| format!("{}", e))?;

        // Judge whether it is a C module or a Rust module
        let file_name = path.file_name().unwrap().to_str().unwrap();
        if file_name.ends_with(".bc") {
            if targets.iter().any(|t| file_name.starts_with(t)) {
                r_modules.push(module)
            }
            // or it's just dependencies crates
        } else if file_name.ends_with(".o") {
            c_modules.push(module);
        } else {
            panic!("Unsupported file type: {}", file_name);
        }
    }

    let ir_info = IRInfo::new(r_modules, c_modules);

    Ok(ir_info)
}
